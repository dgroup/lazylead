#!/usr/bin/env ruby

# The MIT License
#
# Copyright (c) 2019-2020 Yurii Dubinka
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom
# the Software is  furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
# OR OTHER DEALINGS IN THE SOFTWARE.

# When sync mode is true, all output is immediately flushed
# to the underlying operating system and is not buffered internally.
STDOUT.sync = true

# Application start time
start = Time.now

require "slop"
require "sqlite3"
require "rainbow"
require "backtrace"
require "memory_profiler"

Thread.current.name = "main"
Encoding.default_external = Encoding::UTF_8
Encoding.default_internal = Encoding::UTF_8

# @todo #/DEV Choose a framework for logging, it might be
#  - https://rubygems.org/gems/logging/versions/2.1.0
#  - https://github.com/TwP/logging
#  Logger should support colored output using any of
#  - http://errtheblog.com/posts/34-a-ruby-rainbow
#  - https://github.com/sickill/rainbow
#  For now FakeLog is used.
log = Lazylead::FakeLog.new

# @todo #/DEV Move ll database file configuration to default arguments
#  which can be overridden using CLI/EVN arguments.
conn = SQLite3::Database.new("../lazylead.db")
conn.results_as_hash = true

opts = Slop.parse(ARGV, strict: false, suppress_errors: true) do |o|
  o.banner = "Usage: lazylead [options] command [arguments]
Available commands:
  #{Rainbow('start').green}
    Start all scheduled tasks
  #{Rainbow('stop').green}
    Stop all scheduled tasks
  #{Rainbow('run').green} command [options]
    Run the task once
  #{Rainbow('teams').green} [options]
    Show all registered teams
  #{Rainbow('team').green} [ID...] [options]
    Show team details with scheduled tasks
  #{Rainbow('systems').green} [options]
    Show all defined ticketing systems
  #{Rainbow('system').green} [ID...] [options]
    Show ticketing system details
  #{Rainbow('tasks').green} [options]
    Show all scheduled tasks
  #{Rainbow('task').green} [ID...] [options]
    Show particular task details
Available options:"
  o.bool "-h", "--help", "Show these instructions"
  o.bool "--trace", "Show full stack trace in case of a problem"
  o.bool "--memory-dump", "Dump memory snapshot afterwards, to the console",
         default: false
  o.string "--pretty",
           "Logging format, e.g. short, full, compact (default: short)",
           required: true,
           default: "short"
  o.on "--no-colors", "Disable colors in the output" do
    Rainbow.enabled = false
  end
  o.on "--verbose", "Enable extra logging information" do
    log.verbose
  end
  o.on "-v", "--version", "Show current version" do
    log.debug "v0.0.0"
    exit
  end
end

commands = opts.arguments.reject { |a| a.start_with?("-") }
command = commands[0]
if command.nil?
  raise "A command required, try --help" unless opts.help?

  log.debug(opts.to_s)
  exit
end
args = opts.arguments
args << "--help" if opts.help?

log.debug("Memory footprint at start is #{Lazylead::Allocated}")

cmd = lambda do
  case command
  when "start"
    require_relative "../lib/lazylead/command/start"
    Lazylead::Start.new(conn: conn, log: log).run(args)
  when "ps"
    log.debug "ps"
  when "stop"
    log.debug("stop")
  when "run"
    log.debug("run")
  when "teams"
    log.debug("team")
  when "tasks"
    log.debug("tasks")
  when "task"
    log.debug("tasks")
  when "systems"
    log.debug("systems")
  when "system"
    log.debug("system")
  else
    raise "Command '#{command}' is not supported"
  end
  return 0
rescue StandardError => e
  log.error("#{e.message} (#{e.class.name})")
  log.error(Backtrace.new(e)) if opts["trace"]
  return -1
end

code = 0
if opts["memory-dump"]
  MemoryProfiler.report(top: 20) { code = cmd.call }.pretty_print
else
  code = cmd.call
end
log.debug("Memory footprint at the end is #{Lazylead::Allocated}")

if code.zero?
  log.debug("Successfully finished in #{Lazylead::Age.new(start)}")
else
  log.debug("Failed in #{Lazylead::Age.new(start)}")
  exit(code)
end
